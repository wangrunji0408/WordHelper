# WordHelper 设计文档

WordHelper是一个背单词软件。

本文将从以下几个方面介绍这个程序的设计思路和整体结构：

* 主要功能和特色
* 整体架构
* 模块介绍
* 文件结构
* 不足和改进



## 主要功能和特色

* 背单词软件的主要功能：单词查找，修改，单词测试，文本分析。
* 跨平台，支持Windows、Linux、Mac.
* 支持多用户

## 整体架构
本程序的整体架构分为三大层，从下到上依次是`Word` `Kernel` `Shell`，它们是**依次包含关系**。
* Word模块负责单词信息和数据库。
* Kernel模块负责核心功能的实现。它包含登陆器`Logger`类，核心`Kernel`类，和若干`SubKernel`类。每个小功能都委托给一个专门的子Kernel来处理。
* Shell模块负责命令行UI，它是Kernel和用户之间的桥梁。

由于它们都是相对独立的模块，因此在文件上将它们的头文件和实现文件分别**置于单独的文件夹**，在编译上分别把它们**打包成动态链接库**。
关于模块、类与文件的关系，请参阅文末**文件结构-代码目录**。

## 模块介绍

### Word模块
Word模块由两部分组成：单词结构的定义，数据库接口及实现。

#### 单词结构的定义
一个单词的完整信息保存在`WordInfo`结构中。由于单词信息分为**词典信息**和**用户信息**，我们分别把它们保存在`WordDictInfo`和`WordUserInfo`结构中，让`WordInfo`同时继承这两个类。其中**词典信息**在运行时不可修改，**用户信息**可被修改
我们参考了`Mac词典`等软件中单词信息的结构，将一个单词的结构分为3层：单词，含义，句子，即`WordInfo` `Meaning` `Sentence`结构。每个结构的具体内容可参阅`word.h`。
值得一提的是，我们用**标签**来实现项目要求中的很多功能。标签分为**系统标签**和**用户标签**。系统标签的内容是固定的，其中有**难度标签**（如`CET4` `TOEFL`等）。用户标签可由用户自定义设定，也可由系统生成，如**记忆标签**（如`生词` `熟词` `常见易忘词`等）。

#### 单词信息的保存
对于单词信息在文件中的存储格式，考虑到一个单词内部的信息多且结构复杂，我们认为项目要求中**单词库一行一个单词**的条件在**文件存取方便性**和**文本文件可读性**上不能令人满意。
因此我们采用了**JSON格式**在文件中存储单词信息，使得纯文本文件清晰可读。

每次程序运行结束时，会生成`wordlist.txt`文件，一行一个单词，没有其它信息。

#### 数据库接口与实现
数据库提供以下接口：
* 词库信息的存取
* 用户信息的存取与清空
* 用一个字符串索引一个单词
* 用一个filter函数查找满足要求的所有单词

在确定了接口后，这个数据库就可以有很多种实现方式，如：
* 使用`std::map`索引单词
* 使用数据结构`Trie`索引单词
* 从网络数据库加载单词信息

由于时间限制，我们只实现了最简单的第一种方式。当未来需求改变时，我们可以使用其它实现方式来应对。

### Kernel模块
Kernel模块负责核心功能的实现。它包含登陆器`Logger`类，核心`Kernel`类，和若干`SubKernel`类。每个小功能都委托给一个专门的子Kernel来处理。每个类都提供了日志记录功能，在必要时它们可以向std::clog输出运行状态和错误信息。

#### Logger类
Logger类为**支持多用户**而设计。它负责管理用户，读入登录信息（如用户名，密码），在登陆成功后返回一个Kernel类。因此它可以视为Kernel类的**简单工厂**。

#### Kernel类
Kernel类负责程序的**核心功能**，如：存取用户配置，存取单词数据库，提供查看和修改配置的接口，新建并返回子Kernel。因此它也可以视为所有子Kernel类的**简单工厂**。

#### Config类
Config类保存了程序的**一切配置信息**，并提供了向文件存取的方法。他是Kernel类的核心内部成员，并不向外暴露，因此为了方便我们把它设计为struct结构。

#### TestKernel类
TestKernel类负责实现**单词测试**的功能。目前它有4个子类，分别实现不同的测试模式：
* Recall：回忆模式。给出英文，询问用户是否记得中文意思。
* Spell：拼写模式。给出中文，让用户拼写英文。
* choiceC：选择中文模式。给出英文+若干中文选项。
* choiceE：选择英文模式。给出中文+若干英文选项。

单词测试功能还有一些可变的部分，我们用策略模式来实现：
* 选词策略：`WordSelectStrategy`类
  相当于一个函数，输入一个数据库，输出排好序的单词列表用于测试。
  目前只实现了Random策略，未来可实现类似扇贝单词的高级选词策略。
* 记忆策略：（尚未实现）
  相当于一个函数，输入一个单词和测试中用户的反馈（如反应时间、是否答对），修改这个单词的记忆等级。

#### WordKernel类
WordKernel类负责实现**单词信息修改**的功能，但它只提供修改**用户信息**的接口，**词典信息**并不能被修改。

#### TestAnalyzeKernel类
TestAnalyzeKernel类负责实现**文本分析**的功能。它依赖于一个数据库，可以载入一段文本，并给出以下功能接口：
* 统计一个单词的出现频率
* 按频率降序排序给出单词列表
* 找出所有在和不在单词库中的单词

### Shell模块

Shell模块即UI模块，负责和用户交互。它控制显示界面，接受用户的指令，调用Kernel模块的接口完成相应功能，并得到返回值，更新显示界面。它是用户和Kernel之间沟通的桥梁。

目前Shell模块只实现了命令行窗口UI，未来可以完全另写一个模块代替Shell的位置来实现GUI或其它交互方式。这些不同的Shell可以同时运行，并可以引用同一个Kernel。这样用户可以通过不同接口来控制同一个程序。

#### Shell_Base类

Shell_Base类是所有Shell的基类。它包含一个输入流，一个输出流，一个Kernel指针，和一个构造函数。

#### Shell类

目前我们只用了这一个类来完成Shell的全部功能，方法是将不同的功能委托给不同的成员函数来实现。这种实现简单方便，但当需要加入新功能时不可避免地要修改类的头文件。这是我们以后需要改进的地方，也许可以通过类似Kernel中的做法——将功能委托给新的类来解决。

不过现在，我们还是要介绍一下Shell类中的各类函数：

* 基础输出函数：如输出一行字符串，输出标题，输出错误信息，清屏等等。

* 单词显示函数：简单显示，全部显示，调试显示。

* 功能实现函数：各个模式的单词测试，文本分析，查找单词，单词管理。

  这些函数都要向Kernel类索要相应的子Kernel类来完成功能。

* 命令解析函数：等待用户输入命令并解析之，完成相应功能或给出错误信息。



## 文件结构

### 根目录

* `source`：所有源代码

* `resource`：所有资源文件，包括：

  * 格式化词库
  * 原始词库
  * 文本分析样例

* `docs`：所有说明文档和展示PPT

* `runtime`：程序运行时所需的一切文件

  在`src`中运行`make`后，它会将最终版的程序生成到这个文件夹下以系统名命名的子文件夹中。如在Windows系统下，最终程序的运行目录是`runtime/Windows`。

### 代码目录

* `kernel`：Kernel模块的所有源代码

  | 类                      | 头文件                    | 实现文件                     |
  | ---------------------- | :--------------------- | ------------------------ |
  | Kernel                 | kernel.h               | kernel*.cpp(4)           |
  | Logger                 | logger.h               | logger.cpp               |
  | Config                 | config.h               | config.cpp               |
  | WordKernel             | word_kernel.h          | word_kernel.cpp          |
  | TextAnalyzeKernel*(2)  | test_analyze_kernel.h  | test_analyze_kernel.cpp  |
  | TestKernel*(6)         | test_kernel.h          | test_kernel.cpp          |
  | WordSelectStrategy*(2) | word_select_strategy.h | word_select_strategy.cpp |

* `shell`：Shell模块的所有源代码

  | Shell的函数 | 实现文件                       |
  | -------- | -------------------------- |
  | 基础输出     | shell_print.cpp            |
  | 单词显示     | shell_print.cpp            |
  | 搜索单词功能   | shell_search.cpp           |
  | 单词测试功能   | shell_voctest.cpp          |
  | 文本分析功能   | shell_textanalyze.cpp      |
  | 单词管理功能   | shell_wordmanage.cpp       |
  | 主界面命令解析  | shell.cpp                  |
  | 单词测试命令解析 | shell_test_word_manage.cpp |
  | 单词管理命令解析 | shell_wordmanage.cpp       |

* `word`：Word模块的所有源代码，包含了Jsoncpp库。

  | 类                             | 头文件          | 实现文件                 |
  | ----------------------------- | ------------ | -------------------- |
  | Sentence,Meaning,Word*Info(3) | word.h       | word.cpp,word_io.cpp |
  | DataBase,DataBaseImpl         | database.h   | database.cpp         |
  | Json::*                       | /json/json.h | jsoncpp.cpp          |


* `zjl_worddata`：解析原始词库时所用到的所有源代码，不属于最终程序。

### 运行目录

即`runtime/$(OS_NAME)/`下：

* `main`：主程序

* `libkernel.dll` `libshell.dll` `libword.dll`：3个动态链接库（后缀因系统而异）

* `dictionary.txt`：词库文件

* `user_data/`：用户信息目录

  其中每个用户的信息保存在`user_data/$(USER_NAME)/`文件夹中。

  这个文件夹中具体信息如下：

  * `config.txt`：用户配置文件
  * `user_word.txt`：用户单词数据

## 不足和改进

我们认为我们的程序有以下不足：

1. 没有很好解决Windows乱码问题，现在需要用户手动转码。

   可能的解决方案：内置转码小工具，在Windows下make时对所有源代码和资源文件自动转码。

2. 不支持多语言界面。

   可能的解决方案：实现界面多语言框架。

3. Shell模块只有一个类，没有很好地分离功能。

   可能的解决方案：将功能分离到新的类中。

4. 命令行界面不支持自动补全、切换到历史命令等高级功能。且现在Shell中命令解析部分的实现依然是传统命令式编程的if-else风格。

   可能的解决方案：学习使用命令窗口专用函数，设计新的框架或套用已有框架。

5. 词库信息不够完善。

   可能的解决方案：交给zjl了！